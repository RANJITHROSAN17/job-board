<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Golang REST API Example [Without Framework]</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <meta name="title" content="Golang REST API Example [Without Framework]" />
    <meta name="keywords" content="golang rest api, golang rest api example, golang servemux, golang servemux example, golang rest api tutorial, golang tutorial, golang, golang api" />
    <meta name="description" content="Golang REST API Example [Without Framework]" />
    <meta itemprop="name" content="Golang REST API Example [Without Framework]">
    <meta itemprop="description" content="Golang REST API Example [Without Framework]">
    <meta itemprop="image" content="https://golang.cafe/s/img/cafe.jpg">
    <meta property="og:url" content="https://golang.cafe">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Golang REST API Example [Without Framework]">
    <meta property="og:description" content="Golang REST API Example [Without Framework]">
    <meta property="og:image" content="https://golang.cafe/s/img/cafe.jpg">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Golang REST API Example [Without Framework]">
    <meta name="twitter:description" content="Golang REST API Example [Without Framework]">
    <meta name="twitter:image" content="https://golang.cafe/s/img/cafe.jpg">
    <meta name="twitter:site" content="@golangcafe"/>
    <style type="text/css">
body{background:#f7f7f7;}
      input,textarea,select,button,option,html,body{font-family:Menlo,"Courier New",monospace;font-size:18px;font-stretch:normal;font-style:normal;font-weight:400;line-height:29.7px}input,textarea,select,button,option,html,body{font-family:Menlo,"Courier New",monospace;font-size:18px;font-stretch:normal;font-style:normal;font-weight:400;line-height:29.7px}th{font-weight:600}td,th{border-bottom:1.08px solid #595959;overflow:auto;padding:14.85px 18px;text-align:left;vertical-align:top}thead th{border-bottom-width:2.16px;padding-bottom:6.3px}table{display:table;overflow-x:auto}input,textarea,select,button,option,html,body{font-family:Menlo,"Courier New",monospace;font-size:18px;font-stretch:normal;font-style:normal;font-weight:400;line-height:29.7px}fieldset{display:flex;flex-direction:row;flex-wrap:wrap}fieldset legend{margin:18px 0}input,textarea,select,button{border-radius:3.6px;display:inline-block;padding:9.9px}input+label,input+input[type="checkbox"],input+input[type="radio"],textarea+label,textarea+input[type="checkbox"],textarea+input[type="radio"],select+label,select+input[type="checkbox"],select+input[type="radio"],button+label,button+input[type="checkbox"],button+input[type="radio"]{page-break-before:always}input,select,label{margin-right:3.6px}textarea{min-height:90px;min-width:360px}label{display:inline-block;margin-bottom:12.6px}label+*{page-break-before:always}label>input{margin-bottom:0}input[type="submit"],input[type="reset"],button{background:#f2f2f2;color:#191919;cursor:pointer;display:inline;margin-bottom:18px;margin-right:7.2px;padding:6.525px 23.4px;text-align:center}input[type="submit"]:hover,input[type="reset"]:hover,button:hover{background:#d9d9d9;color:#000}input[type="submit"][disabled],input[type="reset"][disabled],button[disabled]{background:#e6e5e5;color:#403f3f;cursor:not-allowed}input[type="submit"],button[type="submit"]{background:#000090;color:#fff}input[type="submit"]:hover,button[type="submit"]:hover{background:#0000c5;color:#ffffff}input,select,textarea{margin-bottom:18px}input[type="text"],input[type="password"],input[type="email"],input[type="url"],input[type="phone"],input[type="tel"],input[type="number"],input[type="datetime"],input[type="date"],input[type="month"],input[type="week"],input[type="color"],input[type="time"],input[type="search"],input[type="range"],input[type="file"],input[type="datetime-local"],select,textarea{border:1px solid #595959;padding:5.4px 6.3px}input[type="checkbox"],input[type="radio"]{flex-grow:0;height:29.7px;margin-left:0;margin-right:9px;vertical-align:middle}input[type="checkbox"]+label,input[type="radio"]+label{page-break-before:avoid}select[multiple]{min-width:270px}input,textarea,select,button,option,html,body{font-family:Menlo,"Courier New",monospace;font-size:18px;font-stretch:normal;font-style:normal;font-weight:400;line-height:29.7px}kbd,samp,var,output{font-family:Menlo,Monaco,Consolas,"Courier New",monospace;font-size:14.4px}pre{border-left:1.8px solid #59c072;line-height:25.2px;overflow:auto;padding-left:18px}kbd{background:#daf1e0;border-radius:3.6px;color:#2a6f3b;display:inline-block;line-height:18px;padding:3.6px 6.3px 2.7px}kbd{background:#2a6f3b;color:#fff}mark{background:#ffc;padding:0 3.6px}input,textarea,select,button,option,html,body{font-family:Menlo,"Courier New",monospace;font-size:18px;font-stretch:normal;font-style:normal;font-weight:400;line-height:29.7px}h1,h2,h3,h4,h5,h6{color:#000;margin-bottom:18px}h1{font-size:36px;font-weight:500;line-height:41.4px;margin-top:72px}h2{font-size:25.2px;font-weight:400;line-height:30.6px;margin-top:54px}h3{font-size:21.6px;line-height:27px;margin-top:36px}h4{font-size:18px;line-height:23.4px;margin-top:18px}h5{font-size:14.4px;font-weight:bold;line-height:21.6px;text-transform:uppercase}h6{color:#595959;font-size:14.4px;font-weight:bold;line-height:18px;text-transform:uppercase}input,textarea,select,button,option,html,body{font-family:Menlo,"Courier New",monospace;font-size:18px;font-stretch:normal;font-style:normal;font-weight:400;line-height:29.7px}a{color:#000090;text-decoration:none}a:hover{text-decoration:underline}hr{border-bottom:1px solid #595959}figcaption,small{font-size:15.3px}figcaption{color:#595959}var,em,i{font-style:italic}dt,strong,b{font-weight:600}del,s{text-decoration:line-through}ins,u{text-decoration:underline}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}*{border:0;border-collapse:separate;border-spacing:0;box-sizing:border-box;margin:0;max-width:100%;outline:0;padding:0;vertical-align:baseline}html,body{width:100%}html{height:100%}body{color:#1a1919;}p,ul,ol,dl,blockquote,hr,pre,table,form,fieldset,figure,address{margin-bottom:29.7px}section{margin-left:auto;margin-right:auto;width:780px}article,header,footer{padding:43.2px}article{word-wrap: break-word;background:#fff;border:1px solid #d9d9d9;border-radius:7.2px}nav{text-align:center}nav ul{list-style:none;margin-left:0;text-align:center}nav ul li{display:inline-block;margin-left:9px;margin-right:9px;vertical-align:middle}nav ul li:last-child{margin-right:0}ol,ul{margin-left:31.5px}li dl,li ol,li ul{margin-bottom:0}dl{display:inline-block}dt{padding:0 18px}dd{padding:0 18px 4.5px}dd:last-of-type{border-bottom:1.08px solid #595959}dd+dt{border-top:1.08px solid #595959;padding-top:9px}blockquote{border-left:2.16px solid #595959;padding:4.5px 18px 4.5px 15.84px}blockquote footer{color:#595959;font-size:13.5px;margin:0}blockquote p{margin-bottom:0}img{height:auto;margin:0 auto}figure img{display:block}/*# sourceMappingURL=tacit-css-1.3.2.min.css.map */
      input{-webkit-appearance: none;-moz-appearance: none;appearance: none;}
      #carbonads{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",Helvetica,Arial,sans-serif}#carbonads{display:inline;max-width:330px;background-color:#f9f9f9;box-shadow:0 1px 4px 1px hsla(0,0%,0%,.1)}#carbonads a{color:inherit;text-decoration:none}#carbonads a:hover{color:inherit}#carbonads span{position:relative;display:block;overflow:hidden}#carbonads .carbon-wrap{display:flex}.carbon-img{display:block;margin:0;line-height:1}.carbon-img img{display:block}.carbon-text{font-size:13px;padding:10px;line-height:1.5;text-align:left}.carbon-poweredby{display:block;padding:8px 10px;background:repeating-linear-gradient(-45deg,transparent,transparent 5px,hsla(0,0%,0%,.025) 5px,hsla(0,0%,0%,.025) 10px) hsla(203,11%,95%,.4);text-align:center;text-transform:uppercase;letter-spacing:.5px;font-weight:600;font-size:9px;line-height:1}
        .menu-header{width: 100%;margin:20px auto;padding:10px;}.menu-header a {white-space:pre;color: black;font-size: 20px;font-weight: bold;padding: 15px;}
    </style>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/themes/prism.min.css" rel="stylesheet" />
  </head>
  <body>
    <header style="padding:0;">
      <nav class="menu-header">
        <small>
            <a href="/">üíº Jobs</a>
            <a href="/Golang-Developer-Salary-Remote">üìä Salaries</a>
            <a href="/Companies-Using-Golang">üè¢ Companies</a>
            <a href="/Golang-Developers">üë§ Developers</a>
          <br>
        </small>
      </nav>
    </header>
    <section style="margin:30px auto;">
      <article>
<h1 class="code-line" data-line-start=0 data-line-end=1 ><a id="Golang_REST_API_Example_Without_Framework_0"></a>Golang REST API Example [Without Framework]</h1>
<p class="has-line-data" data-line-start="2" data-line-end="3">The Go (Golang) standard library offers a vast amount of primitives that can be applied to a variety of problems. One of them is the HTTP ServeMux, which is a request multiplexer and allows us to map a set to requests into handlers. By the end of this article we are going to:</p>
<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CE7ITK3J&placement=golangcafe" id="_carbonads_js"></script><br />
<ul>
<li class="has-line-data" data-line-start="4" data-line-end="5">See how to implement a simple REST API just with the Go standard library</li>
<li class="has-line-data" data-line-start="5" data-line-end="6">Use the Go ServeMux type to route requests to handlers</li>
<li class="has-line-data" data-line-start="6" data-line-end="8">Use minimal scaffolding to implement a basic JSON REST API</li>
</ul>
<h2 class="code-line" data-line-start=8 data-line-end=9 ><a id="Using_Go_ServeMux_8"></a>Using Go ServeMux</h2>
<p class="has-line-data" data-line-start="10" data-line-end="11">The <a href="https://golang.org/pkg/net/http/#ServeMux">ServeMux</a> type is the main component of our API as it allows us to route set of requests into handlers based on the request pattern. Although the pattern matching is limited and we have to do a fair amount of work to map requests to handlers based on regular expressions and http methods, we can easily add the missing pieces.</p>
<p class="has-line-data" data-line-start="12" data-line-end="13">Let‚Äôs see a basic example</p>
<pre><code class="language-go" data-line-start="15" data-line-end="27">type userHandler struct {}

func (h *userHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // all users request are going to be routed here
}

func main() {
    mux := http.NewServeMux()
    mux.Handle(&quot;/users/&quot;, &amp;userHanlder{})
    http.ListenAndServe(&quot;:8080&quot;, mux)
}
</code></pre>
<p class="has-line-data" data-line-start="28" data-line-end="29">Let‚Äôs add a switch statement to drive our requests to their respective handlers</p>
<pre><code class="language-go" data-line-start="31" data-line-end="62">var (
    listUserRe = regexp.MustCompile(`^\/users[\/]*$`)
    getUserRe  = regexp.MustCompile(`^\/users\/(\d+)$`)
    createUserRe = regexp.MustCompile(`^\/users[\/]*$`)
)
type userHandler struct {}

func (h *userHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(&quot;content-type&quot;, &quot;application/json&quot;)
    switch {
    case r.Method == http.MethodGet &amp;&amp; listUserRe.MatchString(r.URL.Path):
        h.List(w, r)
        return
    case r.Method == http.MethodGet &amp;&amp; getUserRe.MatchString(r.URL.Path):
        h.Get(w, r)
        return
    case r.Method == http.MethodPost &amp;&amp; createUserRe.MatchString(r.URL.Path):
        h.Create(w, r)
        return
    default:
        notFound(w, r)
        return
    }
}

func main() {
    mux := http.NewServeMux()
    mux.Handle(&quot;/users/&quot;, &amp;userHanlder{})
    http.ListenAndServe(&quot;:8080&quot;, mux)
}
</code></pre>
<p class="has-line-data" data-line-start="63" data-line-end="64">Now we just need to implement the respective handlers for each request and add some storage. We are going to add a in-memory storage for this example, but you could add any type of storage that best fits your needs.</p>
<pre><code class="language-go" data-line-start="66" data-line-end="109">// user represents our REST resource
type user struct {
    ID   string `json:&quot;id&quot;`
    Name string `json:&quot;name&quot;`
}

// our in-memory datastore
// rememeber to guard map access with a mutex for concurrent access
type datastore struct {
    m map[string]user
    *sync.RWMutex
}

type userHandler struct {
    store *datastore
}

// Get is one of the request/response handlers and is responsible for
// returning a User given its ID
// it will parse the user id from within the URL Path in the request
func (h *userHandler) Get(w http.ResponseWriter, r *http.Request) {
    matches := getUserRe.FindStringSubmatch(r.URL.Path)
    if len(matches) &lt; 2 {
        notFound(w, r)
        return
    }
    h.store.RLock()
    u, ok := h.store.m[matches[1]]
    h.store.RUnlock()
    if !ok {
        w.WriteHeader(http.StatusNotFound)
        w.Write([]byte(&quot;user not found&quot;))
        return
    }
    jsonBytes, err := json.Marshal(u)
    if err != nil {
        internalServerError(w, r)
        return
    }
    w.WriteHeader(http.StatusOK)
    w.Write(jsonBytes)
}
</code></pre>
<h2 class="code-line" data-line-start=110 data-line-end=111 ><a id="JSON_REST_API_final_example_110"></a>JSON REST API final example</h2>
<p class="has-line-data" data-line-start="112" data-line-end="113">Here‚Äôs the final example, once we put together all our pieces</p>
<pre><code class="language-go" data-line-start="115" data-line-end="245">package main

import (
    &quot;encoding/json&quot;
    &quot;net/http&quot;
    &quot;regexp&quot;
    &quot;sync&quot;
)

var (
    listUserRe   = regexp.MustCompile(`^\/users[\/]*$`)
    getUserRe    = regexp.MustCompile(`^\/users\/(\d+)$`)
    createUserRe = regexp.MustCompile(`^\/users[\/]*$`)
)

type user struct {
    ID   string `json:&quot;id&quot;`
    Name string `json:&quot;name&quot;`
}

type datastore struct {
    m map[string]user
    *sync.RWMutex
}

type userHandler struct {
    store *datastore
}

func (h *userHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    w.Header().Set(&quot;content-type&quot;, &quot;application/json&quot;)
    switch {
    case r.Method == http.MethodGet &amp;&amp; listUserRe.MatchString(r.URL.Path):
        h.List(w, r)
        return
    case r.Method == http.MethodGet &amp;&amp; getUserRe.MatchString(r.URL.Path):
        h.Get(w, r)
        return
    case r.Method == http.MethodPost &amp;&amp; createUserRe.MatchString(r.URL.Path):
        h.Create(w, r)
        return
    default:
        notFound(w, r)
        return
    }
}

func (h *userHandler) List(w http.ResponseWriter, r *http.Request) {
    h.store.RLock()
    users := make([]user, 0, len(h.store.m))
    for _, v := range h.store.m {
        users = append(users, v)
    }
    h.store.RUnlock()
    jsonBytes, err := json.Marshal(users)
    if err != nil {
        internalServerError(w, r)
        return
    }
    w.WriteHeader(http.StatusOK)
    w.Write(jsonBytes)
}

func (h *userHandler) Get(w http.ResponseWriter, r *http.Request) {
    matches := getUserRe.FindStringSubmatch(r.URL.Path)
    if len(matches) &lt; 2 {
        notFound(w, r)
        return
    }
    h.store.RLock()
    u, ok := h.store.m[matches[1]]
    h.store.RUnlock()
    if !ok {
        w.WriteHeader(http.StatusNotFound)
        w.Write([]byte(&quot;user not found&quot;))
        return
    }
    jsonBytes, err := json.Marshal(u)
    if err != nil {
        internalServerError(w, r)
        return
    }
    w.WriteHeader(http.StatusOK)
    w.Write(jsonBytes)
}

func (h *userHandler) Create(w http.ResponseWriter, r *http.Request) {
    var u user
    if err := json.NewDecoder(r.Body).Decode(&amp;u); err != nil {
        internalServerError(w, r)
        return
    }
    h.store.Lock()
    h.store.m[u.ID] = u
    h.store.Unlock()
    jsonBytes, err := json.Marshal(u)
    if err != nil {
        internalServerError(w, r)
        return
    }
    w.WriteHeader(http.StatusOK)
    w.Write(jsonBytes)
}

func internalServerError(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusInternalServerError)
    w.Write([]byte(&quot;internal server error&quot;))
}

func notFound(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusNotFound)
    w.Write([]byte(&quot;not found&quot;))
}

func main() {
    mux := http.NewServeMux()
    userH := &amp;userHandler{
        store: &amp;datastore{
            m: map[string]user{
                &quot;1&quot;: user{ID: &quot;1&quot;, Name: &quot;bob&quot;},
            },
            RWMutex: &amp;sync.RWMutex{},
        },
    }
    mux.Handle(&quot;/users&quot;, userH)
    mux.Handle(&quot;/users/&quot;, userH)

    http.ListenAndServe(&quot;localhost:8080&quot;, mux)
}
</code></pre>
<p class="has-line-data" data-line-start="246" data-line-end="247">Here‚Äôs the source code <a href="https://play.golang.org/p/fbr87Ktb0kQ">https://play.golang.org/p/fbr87Ktb0kQ</a></p>
<h2 class="code-line" data-line-start=248 data-line-end=249 ><a id="Running_and_Testing_our_REST_API_Server_248"></a>Running and Testing our REST API Server</h2>
<p class="has-line-data" data-line-start="250" data-line-end="251">Try to save our example in a file and start your server</p>
<pre><code class="language-go" data-line-start="253" data-line-end="256">‚ûú go run server.go

</code></pre>
<p class="has-line-data" data-line-start="257" data-line-end="258">And this is how our REST APIs works once completed ‚ú®</p>
<pre><code class="language-go" data-line-start="260" data-line-end="275">‚ûú curl http://localhost:8080/users
[{&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;bob&quot;}]

‚ûú curl http://localhost:8080/users/1
{&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;bob&quot;}

‚ûú curl -X POST -H 'content-type: application/json' --data '{&quot;id&quot;: &quot;2&quot;, &quot;name&quot;: &quot;karen&quot;}' http://localhost:8080/users
{&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;karen&quot;}

‚ûú curl http://localhost:8080/users
[{&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;bob&quot;},{&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;karen&quot;}]

‚ûú curl http://localhost:8080/users/2
{&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;karen&quot;}
</code></pre>
<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CE7ITK3J&placement=golangcafe" id="_carbonads_js"></script><br />
                <br />
		<iframe width="560" height="315" src="https://www.youtube.com/embed/8S30eoBSojU" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br />
        <p>
          Ready for your next Golang Job? Join other fellow Gophers, submit your profile and get hired
          <input type="submit" onclick="window.location.href='/Submit-Developer-Profile'" value="Join for Free" style="margin-bottom: 0;"/>
      </p>
      </article>
  </section>
  <footer>
    <nav>
      <small>    
        <a href="/">Golang Jobs</a> &bull;
        <a href="/about">About Golang Cafe</a>
        <br>
      </small>
    </nav>
  </footer>
  <script async src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
  <script async src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-go.min.js"></script>
  <script async src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.js"></script>

  </body>
</html>
